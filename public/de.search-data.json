{"/guides/":{"data":{"":"","hello-world#Hello, World!":"This is a demo of the theme’s documentation layout.\nHello, World! main.gopackage main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } "},"title":"Documentation"},"/guides/first-page-copy-2/":{"data":{"":"","dokumentation#Dokumentation":"","gitlab#GitLab":"","raspberry-pi#Raspberry Pi":"Die folgenden Kapitel geben einen Überblick über zentrale Themen, die für die Entwicklung und Dokumentation des Projekts von Bedeutung sind. Sie decken die Nutzung von Tools, die Dokumentationsstandards und die eingesetzte Hardware ab. Die Kapitel sind in die Bereiche GitLab, Dokumentation und Raspberry Pi unterteilt, um eine klare und strukturierte Darstellung zu gewährleisten.\nGitLab GitLab dient als zentrale Plattform für die Versionskontrolle, Projektmanagement und Zusammenarbeit im Team. Es erleichtert die Organisation von Arbeitspaketen und die Nachverfolgung von Fortschritten, während es gleichzeitig eine robuste Basis für die Verwaltung des Quellcodes bietet.\nDokumentation Die Dokumentation bildet das Rückgrat des Projekts, indem sie sicherstellt, dass alle Entscheidungen, Anforderungen und Umsetzungen klar festgehalten und leicht nachvollziehbar sind. Standards wie das arc42-Template werden verwendet, um eine konsistente und strukturierte Dokumentation zu gewährleisten.\nRaspberry Pi Der Raspberry Pi ist die gewählte Hardwareplattform für die Umsetzung des Projekts. Mit seiner kompakten Bauweise, Energieeffizienz und Flexibilität bietet er eine ideale Grundlage für den Betrieb des Exponats und die Interaktion mit externen Komponenten."},"title":"Einführung"},"/guides/first-page-copy/":{"data":{"":"A simple demo page."},"title":"B"},"/guides/first-page/":{"data":{"":"","applikation#Applikation":"","asindexpage-true#asIndexPage: true":"","externe-anbindung#Externe Anbindung":" asIndexPage: true import { Cards } from ’nextra/components'\nHardwareDieser Abschnitt beschreibt die Hardware-Konfiguration des Raspberry Pi.\nUtilities Applikation Externe Anbindung ","hardware#Hardware":"","utilities#Utilities":""},"title":"A"},"/guides/hardware/":{"data":{"":"Pages can be organized into folders."},"title":"Folder"},"/guides/hardware/leaf/":{"data":{"1-software-installieren#1. Software installieren":"","2-samba-server-konfigurieren#2. Samba-Server konfigurieren":"","3-samba-freigaben-einrichten#3. Samba-Freigaben einrichten":"","4-benutzer-hinzufügen#4. Benutzer hinzufügen":"","5-mit-samba-verbinden#5. Mit Samba verbinden":"","quellenangaben-und-weitere-informationen#Quellenangaben und weitere Informationen":"SMB-ServerDer SMB-Server ermöglicht den Zugriff auf Dateien und Verzeichnisse über das Netzwerk. Der Raspberry Pi wird somit zu einem Dateiserver.\n1. Software installieren Als erstes müssen die benötigten Software-Pakete installiert werden.\nsudo apt-get update sudo apt-get install samba samba-common smbclient -y Dies installiert die folgenden Pakete:\nsamba: SMB-Server-Software samba-common: Gemeinsame Dateien für Samba smbclient: SMB-Client-Software 2. Samba-Server konfigurieren Als erstes wird die Konfigurationsdatei von Samba gesichert und eine neue Konfigurationsdatei erstellt.\nsudo mv /etc/samba/smb.conf /etc/samba/smb.conf_alt sudo nano /etc/samba/smb.conf [global] workgroup = WORKGROUP security = user encrypt passwords = yes client min protocol = SMB2 client max protocol = SMB3 Diese Konfiguration ist ein Minimalbeispiel für eine Samba-Konfiguration.\ntestparm # Parameter überprüfen sudo service smbd restart sudo service nmbd restart 3. Samba-Freigaben einrichten Dieser Abschnitt beschreibt, wie ein Verzeichnis für die Freigabe über Samba eingerichtet wird.\nsudo mkdir /home/pi/algaecare Ein Verzeichnis wird erstellt, das für die Freigabe über Samba vorgesehen ist.\n# Berechtigungen für root sudo chown root:root /home/pi/algaecare sudo chmod 777 /home/pi/algaecare # Berechtigungen für users sudo chown root:users /home/pi/algaecare sudo chmod 770 /home/pi/algaecare # Berechtigungen für pi sudo chown pi:pi /home/pi/algaecare sudo chmod 700 /home/pi/algaecare Berechtigungen für das Verzeichnis werden gesetzt.\nsudo nano /etc/samba/smb.conf [AlgaeCare] comment = AlgaeCare-Freigabe path = /home/pi/algaecare read only = no Der Pfad des zu freigebenden Verzeichnisses wird angegeben, sowie die Berechtigungen für die Freigabe.\n4. Benutzer hinzufügen Wichtig: Die Benutzerverwaltung für Samba findet durch das Betriebssystem und Samba statt. Das bedeutet, Samba benutzt die eingerichteten Benutzernamen und die Datei- und Verzeichnisberechtigungen des Betriebssystems.\nsudo smbpasswd -a pi Das gilt nicht für die Passwörter der Benutzer.\n5. Mit Samba verbinden Um sich mit dem Samba-Server zu verbinden, wird der Dateimanager verwendet. Für genauere Anweisungen bitte die Dokumentation des Dateimanagers konsultieren.\nQuellenangaben und weitere Informationen Samba-Freigabe auf dem Raspberry Pi einrichten ","smb-server#SMB-Server":""},"title":"SMB-Server"},"/sad/":{"data":{"":"Einführung Die Dokumentation der Software-Architektur ist ein wesentlicher Bestandteil des Softwareentwicklungsprozesses. Dieses Software-Architektur-Dokument (SAD) dient als zentrale Quelle, um die Architektur eines Systems umfassend zu beschreiben. Es stellt sicher, dass alle relevanten Aspekte der Softwareentwicklung – von der Planung bis zur Wartung – klar dokumentiert und nachvollziehbar sind.\nDas SAD ist eine lebendige Dokumentation, die während der gesamten Projektdauer aktualisiert wird. Es bildet die Grundlage für die Kommunikation zwischen den verschiedenen Stakeholdern, erleichtert die Zusammenarbeit im Team und dient als Referenz für zukünftige Erweiterungen oder Änderungen. Darüber hinaus stellt es sicher, dass die Qualitätsanforderungen des Systems eingehalten werden.\nProjektkontext Das Projekt Algae Care wurde initiiert, um Schülerinnen und Schüler der Sekundarstufe auf interaktive und innovative Weise für die Bedeutung von Algen und deren Erhalt zu sensibilisieren. Im Rahmen einer Ausstellung des Energieunternehmens Primeo Energie wird das System als zentrales Exponat präsentiert. Es zeigt auf, wie Algen nicht nur zur nachhaltigen Energiegewinnung beitragen, sondern auch eine Schlüsselrolle im ökologischen Gleichgewicht unseres Planeten spielen.\nZiele des SAD Transparenz: Sicherstellen, dass die Architekturentscheidungen nachvollziehbar dokumentiert sind. Kommunikation: Bereitstellung eines gemeinsamen Verständnisses für alle Projektbeteiligten, einschließlich Entwicklern, Architekten und Stakeholdern. Wartbarkeit: Unterstützung der langfristigen Weiterentwicklung und Wartung des Systems. Die Architektur des Systems wurde so gestaltet, dass sie flexibel auf veränderte Anforderungen reagieren kann. Dieses Dokument stellt die notwendigen Informationen bereit, um die Struktur und die zentralen Entwurfsentscheidungen des Systems zu verstehen.\nStruktur des SAD Das SAD folgt der etablierten Struktur und umfasst folgende Kapitel:\nAufgabestellung Qualitätsziele Randbedingungen Kontextabgrenzung Bausteinsicht Laufzeitsicht Verteilungssicht Entwurfsentscheidungen Glossar Mit diesem Dokument soll sichergestellt werden, dass das Projekt sowohl im aktuellen Entwicklungsprozess als auch langfristig erfolgreich ist."},"title":"Software Architecture Documentation"},"/sad/anforderungen/":{"data":{"":"","allgemeine-anforderungen#Allgemeine Anforderungen":"","anforderungen-an-den-ausstellungsstand#Anforderungen an den Ausstellungsstand":"Diese wurden direkt aus der offiziellen Aufgabenstellung übernommen.\nAllgemeine Anforderungen Alle Spiele/Simulationen haben jedoch gemeinsame Anforderungen. Die folgenden allgemeinen Anforderungen wurden von den Auftraggebern in Zusammenarbeit mit den POs und den Coaches festgelegt:\nPrimäre Zielgruppe: Jugendliche im 7. bis 9. Schuljahr **Zeit:**Pro Spielrunde 1-3 Minuten (4 Kinder sollten in ca. 5 Minuten fertig sein). Dies ist wichtig, wenn grössere Schulklassen die Spiele spielen. Die Spiele sind selbsterklärend oder können in 30 Sekunden erklärt werden. Die Spiele müssen eine schnelle Antwortzeit haben (keinen Lag), sonst verlieren die Spieler:innen das Interesse. Konfigurierbare Parameter sollen in eine Datei ausgelagert werden, so dass die Anwendungen in 5 Minuten konfiguriert werden können. Die Spiele sollen mehrsprachig (D, F, E) eingesetzt werden können. Das bedeutet, dass Texte und Strings ausgelagert werden und nicht hart im Code vorhanden sind. Die Übersetzung wird von Primeo gemacht, ausser jemand im Team ist bilingue und möchte das machen, ansonsten genügt eine deutsche Implementierung. Die Sprache soll in der Applikation oder mindestens in einer Konfiguration gewechselt werden können. Wenn möglich sollten die Exponate ohne Internet verwendbar sein, WIFI wäre aber prinzipiell möglich. Die Spiele sollen gut transportierbar sein, da auch Ausstellungen ausserhalb stattfinden können. Das bedeutet: Je mobiler, desto besser, aber ohne Kompromisse bei der Spielidee. Schnell auf- und abbaubar. Sicher und einfach von einer, maximal zwei Personen zu transportieren. Bei sperrigen Exponaten kann die Transportierbarkeit z.B. durch Griffe etc. verbessert werden. Spezielle Anforderungen an die Wartbarkeit und den Betrieb: Tastatur und Maus müssen von aussen anschliessbar sein (über Stecker), allgemein gilt Anschlüsse sollen gut zugänglich sein. Bei Anschlüssen möglichst Standards verwenden. Autostart: Wenn Strom angeschlossen ist, soll die Anwendung starten. Exponat soll nicht komplett verschraubt sein, damit das Innenleben leicht zugänglich ist. 3D-Druckmodelle gehören mit in die Dokumentation. Die Spiele sollten haptische Elemente enthalten (Spielbrett, Spielfiguren, Bedienelemente etc., abhängig vom konkreten Spiel). Berücksichtigen Sie die technischen Anforderungen und die Bedingungen zum Material. Keine Abhängigkeiten von Drittplattformen Technische Rahmenbedingungen Programmiersprache: Java 21. Library: Pi4J Konfiguration: Die Konfiguration der Anwendung wird mit java.util.Properties umgesetzt. Die Konfigurationsdatei muss app.properties heissen und muss im Default-Package abgelegt werden. Es soll die Plain-Text-Variante verwendet werden, nicht die XML-Variante. (Hinweise zur Verwendung von Properties). Datenbank: SQLite DB integriert in die Applikation auf der jeweiligen Plattform. Falls Sie für ihr Spiel zusätzliche Daten persistieren möchten, empfehlen wir, das Datenbanksystem SQLite zu verwenden. SQLite verwendet eine sog. serverless Architektur, das Datenbankverwaltungssystem ist dabei Teil der Applikation. Webserver: Es werden keine zusätzlichen Webserver verwendet. Anforderungen an den Ausstellungsstand Der Stand hat drei Grundfunktionen: Er soll Publikum anlocken, das Spiel vorstellen und das Spielen ermöglichen. Idealerweise geschieht dies durch ein Spielobjekt, ein Poster und zwei Betreuungspersonen. Sie vermitteln dem Publikum Antworten auf folgende Fragen:\nWelches ist das Zielpublikum des Spiels? Worum geht es in diesem Spiel? Wie spielt man das Spiel? (Spielregeln) Was kann man bei diesem Spiel lernen? Wer hat das Spiel hergestellt? Wie bekommt man das Spiel? Welche Systemvoraussetzungen braucht das Spiel? Wie installiere ich das Spiel? Lässt sich das Spiel erweitern? Beim Aufbau des Standes ist darauf zu achten, dass möglichst viele Personen gleichzeitig etwas sehen, lesen, fragen oder tun können.","spezielle-anforderungen-an-die-wartbarkeit-und-den-betrieb#Spezielle Anforderungen an die Wartbarkeit und den Betrieb:":"","technische-rahmenbedingungen#Technische Rahmenbedingungen":""},"title":"Anforderungen"},"/sad/aufgabestellung/":{"data":{"":"","was-ist-algae-care#Was ist Algae Care?":"","wesentliche-features#Wesentliche Features:":"Was ist Algae Care? Algae Care ist ein interaktives Exponat, das die Bedeutung von Algen für Umwelt und Nachhaltigkeit hervorhebt. Es wurde speziell für eine Ausstellung des Energieunternehmens Primeo Energie entwickelt und richtet sich an Schülerinnen und Schüler der Sekundarstufe.\nDas System dient als anschauliches und zugleich informatives Fallbeispiel, das auf spielerische Weise Wissen über die Rolle von Algen in der Energiegewinnung und im ökologischen Gleichgewicht vermittelt. Ziel ist es, die junge Zielgruppe für die Bedeutung des Erhalts von Algen und deren Beitrag zu einer nachhaltigen Zukunft zu sensibilisieren.\nWesentliche Features: Interaktive Lernmodule, die die Rolle von Algen in Ökosystemen und ihre Anwendungen in der Energiegewinnung erklären. Visualisierungen und Simulationen, die das Wachstum von Algen und ihren CO₂-Verbrauch veranschaulichen. Benutzerfreundliches Design, das eine einfache und intuitive Nutzung ermöglicht. Flexibilität, um Inhalte und Funktionen für verschiedene Ausstellungskontexte anpassen zu können. Algae Care verbindet Wissensvermittlung mit interaktiver Technologie, um die Bedeutung von Nachhaltigkeit und Umweltschutz greifbar und spannend zu machen."},"title":"Aufgabenstellung"},"/sad/bausteinansicht/bausteinansicht1/":{"data":{"":"","subsysteme-ebene-1#Subsysteme (Ebene 1)":"(hier genügt eine einfache Darstellung auf Ebene Pakete und Klassen)\nDieser Abschnitt beschreibt die Zerlegung von Algae Care in Module, die sich in der Paketstruktur des Java-Quelltextes widerspiegeln. Die Module der ersten Zerlegungsebene bezeichnen wir in Algae Care als Subsysteme. Diese Subsysteme bilden die grundlegenden Bausteine der Anwendung und definieren deren Verantwortlichkeiten sowie die Schnittstellen zur Interaktion miteinander.\nDie Ebene 1 stellt die Subsysteme dar, einschließlich ihrer Schnittstellen und Abhängigkeiten. Für das zentrale Subsystem Eingabe- und Verarbeitungssystem enthält dieser Überblick auch eine detailliertere Zerlegung in Ebene 2, um die innere Struktur und Funktionsweise genauer zu erläutern.\nDiese Darstellung dient dazu, die Modularität und die klare Trennung der Verantwortlichkeiten im System aufzuzeigen, wodurch die Wartbarkeit und Erweiterbarkeit von Algae Care gewährleistet wird.\nSubsysteme (Ebene 1) graph TD\rsubgraph AlgaeCare\rsubgraph App\rAppStarter\rController\rModel\rView\rend\rsubgraph Hardware\rNFC-Input\rDisplay\rend\rUser\rend\rAppStarter --\u003e|initializes| Controller\rController --\u003e|uses| Model\rController --\u003e|changes| View\rNFC-Input --\u003e|sends event| Controller\rController --\u003e|changes| Display\rUser --\u003e|interacts with| NFC-Input\rDisplay --\u003e|reacts to| User Main Application Components \u003cimg src=\"/classSimple.png\" width=“auto” height=“auto” alt={“error loading image”}/\u003e\nPi4J Hardware Components graph TD\rsubgraph com\rsubgraph pi4j\rsubgraph catalog\rsubgraph components\rSimpleButton\rSimpleLed\rJoystick\rsubgraph base\rDigitalActuator\rDigitalSensor\rSerialDevice\rSpiDevice\rI2CDevice\rPIN\rComponent\rPwmActuator\rend\rend\rend\rend\rend\rSimpleButton --\u003e DigitalSensor\rSimpleLed --\u003e DigitalActuator\rJoystick --\u003e SimpleButton\rSerialDevice --\u003e Component\rSpiDevice --\u003e Component\rI2CDevice --\u003e Component\rPIN --\u003e Component\rPwmActuator --\u003e Component Interconnections Between Components \u003cimg src=\"/classOnlyinheretence.png\" width=“auto” height=“auto” alt={“error loading image”}/\u003e\nInterconnections Between Components including usages \u003cimg src=\"/class.png\" width=“auto” height=“auto” alt={“error loading image”}/\u003e"},"title":"Bausteinsicht"},"/sad/bausteinansicht/schnittstellen/":{"data":{"":"","schnittstellen-im-klassendiagramm#Schnittstellen im Klassendiagramm":"In diesem Kapitel werden sämtliche Schnittstellen beschrieben, über die die Software mit Hardware kommuniziert.\nSimple Darstellung graph TD\rsubgraph AlgaeCare\rsubgraph App\rAppStarter\rController\rModel\rView\rend\rsubgraph Hardware\rNFC-Input\rDisplay\rend\rend\rAppStarter --\u003e|initializes| Controller\rController --\u003e|uses| Model\rController --\u003e|changes| View\rNFC-Input ==\u003e|sends event| Controller\rController ==\u003e|changes| Display Die dick markierten Linien stellen die Schnittstellen dar. Es gibt 2 Schnittstellen:\nNPC-Input -\u003e Controller: Erkannte NFC Eingaben lösen ein Event aus, auf welches der controller reagiert. Controller -\u003e Display: Der Controller verändert die View Elemente und zeigt diese auf dem Display an. Schnittstellen im Klassendiagramm TODO","simple-darstellung#Simple Darstellung":""},"title":"Schnittstellen"},"/sad/bausteinansicht/zustaende/":{"data":{"":"In dieser Seite werden alle “States” (Zustände) beschrieben welches die Applikation haben kann.\nstateDiagram\r[*] --\u003e Start\rStart --\u003e Tutorial : Axolotl wurde eingeworfen\rTutorial --\u003e Idle\rIdle --\u003e Event: Objekt wurde eingeworfen\rstate if_state \u003c\u003cchoice\u003e\u003e\rEvent --\u003e if_state\rif_state --\u003e Idle: Oekosystem bewohnbar und Zeit nicht abgelaufen\rif_state --\u003e GoodEnd: Oekosystem unbewohnbar\rif_state --\u003e BadEnd: Zeit abgelaufen\rGoodEnd --\u003e Start: reset\rBadEnd --\u003e Start: reset Start: Bei Beginn des Spiels wartet das Spiel auf den Einwurf der Axolotl Figur. Tutorial: Wird das Axolotl eingeworfen erklärt dieses kurz das Spiel. Idle: Das Axolotl schwebt im Meer, bis ein Objekt eingeworfen wird. Event: Wird ein Objekt eingeworfen, wird eine Animation und einen Text angezeigt. GoodEnd: Ist die Zeit um und das Ökosystem in gesundem Zustand, bedankt sich das Axolotl. Danach fängt man bei “Start” wieder an. BadEnd: Ist das Ökosystem unbewohnbar, flüchtet das Axolotl. Danach fängt man bei “Start” wieder an. "},"title":"Schntitstellen"},"/sad/begriffe/":{"data":{"":"Diese Definitionen und Abkürzungen dienen als Grundlage für die Kommunikation innerhalb des Teams und mit dem Auftraggeber, um Missverständnisse zu vermeiden.\nBegriff Beschreibung Kommentar RE Requirements Engineering UX User Experience ETC (Abkürzung) Estimated Time of Completion (engl.) - Voraussichtliche Fertigstellungszeit Für Arbeitspakete und Tasks “1d” (Einheit auf Gitlab) Bei den Arbeitspaketen in den ETC der Issues: “1d” ist ein Arbeitstag und zwar definiert als 8h. In Gitlab wird automatisch von 8h in 1d konvertiert. MUSS / DARF NICHT Eine absolute Anforderung, über die nicht verhandelt werden kann. Ein System, das diese Anforderung nicht erfüllt, wird disqualifiziert. In Beschreibung von detaillierten Requirements mit “Soll”-Template (auf Gitlab) SOLL / SOLL NICHT Eine empfohlene Anforderung, über die verhandelt werden kann. Je mehr empfohlene Anforderungen umgesetzt werden, desto besser. In Beschreibung von detaillierten Requirements mit “Soll”-Template (auf Gitlab) DARF / MUSS NICHT Eine optionale Anforderung. Ein System kann die Anforderung implementieren, wenn der Anbieter dies beschließt. Die Beteiligten nutzen die Anforderung, wenn das System sie erfüllt. In Beschreibung von detaillierten Requirements mit “Soll”-Template (auf Gitlab) Gitlab Issue Weight: 1 - 3 Wie wichtig die Requirements sind, von 1: Nicht wichtig, bis 3: Hohe Priorität In Gitlab Issues Eingabetrichter Ein Trichter, in welchen die Alltagsobjekte eingeworfen und ausgelesen werden können. Der Trichter führt durch eine Öffnung in das Gehäuse. In Gitlab Issues Feature 1.1 Nachhaltigkeit Ein Konzept, das darauf abzielt, Ressourcen so zu nutzen, dass zukünftige Generationen sie ebenfalls nutzen können. Interaktion Die Handlungen, die ein Benutzer mit dem Exponat ausführt, wie das Platzieren von Objekten oder das Beobachten von Rückmeldungen. Sichtbare Rückmeldung Veränderungen auf dem Bildschirm, die zeigen, welche Wirkung eine Handlung auf die Algen hat. Alge Ein pflanzenähnlicher Organismus, der in Gewässern lebt und Sauerstoff produziert. Es gibt gute und schlechte Algenarten, die sich unterschiedlich auf die Umwelt auswirken können. Alltagsobjekt Diese Objekte werden 3D-gedruckt und dienen den Nutzern als Eingabe. Jedes Alltagsobjekt hat einen anderen Einfluss auf das Ökosystem, welcher auf dem Bildschirm zu sehen ist. Geplante Alltagsobjekte: Plastikflasche (schlecht), Abfall (schlecht), Kompost (weniger schlecht). "},"title":"Begriffe"},"/sad/entwurfsentscheidungen/":{"data":{"":"","entscheidung-1-wie-erkennt-algae-care-alltagsobjekte-mittels-rfid-technologie#Entscheidung 1: Wie erkennt Algae Care Alltagsobjekte mittels RFID-Technologie?":"In diesem Abschnitt werden zwei besonders interessante Entscheidungen beleuchtet, die beim Entwurf von Algae Care getroffen wurden. Diese Entscheidungen waren entscheidend für die Architektur, Funktionalität und Benutzererfahrung des Systems und spiegeln die Abwägungen zwischen verschiedenen Anforderungen und technischen Möglichkeiten wider.\nZiel dieses Abschnitts ist es, die Hintergründe und Beweggründe hinter den Entwurfsentscheidungen transparent zu machen. Dadurch soll ein besseres Verständnis für die Architektur des Systems vermittelt werden, sowie die Auswirkungen dieser Entscheidungen auf die Funktionalität, Wartbarkeit und Erweiterbarkeit von Algae Care.\nEntscheidung 1: Wie erkennt Algae Care Alltagsobjekte mittels RFID-Technologie? Zur Fragestellung Eine zentrale Anforderung an Algae Care ist die zuverlässige und präzise Erkennung der 3D-gedruckten Alltagsobjekte, die als Eingabemedium dienen. Wie erfolgt die Identifikation dieser Objekte?\nDie Erkennung basiert auf der Verwendung von RFID-Tags, die an den Objekten befestigt werden, sowie einem RFID-Reader, der diese Tags ausliest. Es stehen verschiedene Frequenzbereiche (LF und HF) sowie mehrere Reader- und Tag-Optionen zur Auswahl. Jede dieser Optionen hat spezifische Vor- und Nachteile, die die Robustheit, Benutzerfreundlichkeit und Anpassungsfähigkeit des Systems beeinflussen.\nRelevante Einflussfaktoren Randbedingungen Betrieb auf Raspberry Pi mit Pi4J-Bibliothek. Minimierung von Interferenzen durch benachbarte RFID-Tags. Robustheit gegenüber äußeren Einflüssen (z. B. Material des Gehäuses oder Umgebung). Maßgeblich betroffene Qualitätsmerkmale Zuverlässigkeit: Störungsfreies Auslesen der Tags, auch bei hoher Nutzung. Benutzerfreundlichkeit: Sofortige und präzise Erkennung der eingegebenen Objekte. Flexibilität: Möglichkeit, neue Objekte und Tags einfach hinzuzufügen. Betroffene Risiken Interferenzen durch Tags, die in der Nähe gelagert werden. Lesefehler durch Materialdämpfung (z. B. durch Gehäusematerial oder Mehrschichtaufbau). Kompatibilitätsprobleme zwischen Readern und Raspberry Pi 5. Betrachtete Alternativen Frequenzbereiche: LF (Low Frequency): Weniger störanfällig durch geringere Reichweite. Höhere Robustheit bei nah beieinander gelagerten Tags. HF (High Frequency): Einfachere Verfügbarkeit der Hardware. Kompatibilität mit bestehenden Technologien wie Smartphones. RFID-Reader: Option 1: RC522 (HF): Günstig und kompatibel mit HF-Tags. Option 2: ACR122U (HF): Unterstützt das Schreiben und Lesen von Tags, bietet jedoch eingeschränkte Kompatibilität mit Raspberry Pi 5. RFID-Tags: LF-Tags (z. B. Jetons): Robuster und weniger anfällig für Störungen, jedoch teurer und schwerer erhältlich. HF-Tags (z. B. Klebetags): Einfach zu montieren, kostengünstig und kompatibel mit RC522, aber potenziell störanfälliger. Entscheidung Nach Abwägung der Qualitätsziele und Risiken wurde entschieden:\nRFID-Frequenz: LF (Low Frequency) wird verwendet, um Störungen durch benachbarte Tags zu minimieren und eine höhere Zuverlässigkeit im Ausstellungskontext zu gewährleisten. Reader: Ein LF-Reader, der mit Pi4J kompatibel ist, wird integriert. Falls es Kompatibilitätsprobleme gibt, kann ein Mikrocontroller (z. B. Arduino) zwischengeschaltet werden. Tags: Robuste LF-Tags (Jetons) werden bevorzugt, da sie besser für den langfristigen Einsatz und die wiederholte Nutzung geeignet sind. Begründung Die Entscheidung für LF und robuste Tags gewährleistet die Zuverlässigkeit des Systems und minimiert potenzielle Interferenzen. Der Leseradius ist optimal, um eine eindeutige Identifizierung der eingegebenen Objekte zu ermöglichen, ohne dass andere Tags versehentlich ausgelesen werden. Darüber hinaus ist das System skalierbar und kann bei Bedarf durch zusätzliche Tags oder neue Hardware erweitert werden."},"title":"Entwurfssentscheidungen"},"/sad/kontextabgrenzung/":{"data":{"":"","fachlicher-kontext#Fachlicher Kontext":"","technischer--oder-verteilungskontext#Technischer- oder Verteilungskontext":"In diesem Abschnitt wird das Umfeld von Algae Care beschrieben, um die Rolle des Exponats innerhalb der Ausstellung und seine Interaktion mit der Umgebung klar zu definieren. Der Fokus liegt darauf, die Zielgruppe des Systems zu identifizieren und die Schnittstellen zu externen Systemen oder Komponenten zu beschreiben.\nDie Kontextabgrenzung ermöglicht es, das Projekt besser einzuordnen, indem sie die Grenzen des Systems sowie seine Abhängigkeiten und Wechselwirkungen mit anderen Systemen oder Elementen aufzeigt. Dadurch wird sichergestellt, dass alle Beteiligten ein gemeinsames Verständnis über den Anwendungsbereich und die technischen Rahmenbedingungen des Exponats teilen.\nDieser Abschnitt beantwortet folgende Fragen:\nFür welche Benutzerinnen und Benutzer ist Algae Care vorgesehen? Mit welchen externen Systemen oder Komponenten interagiert das Exponat? Welche Rolle spielt das Exponat im Gesamtkontext der Ausstellung? Die präzise Abgrenzung des Kontexts ist entscheidend, um die Anforderungen an das System zu definieren und dessen erfolgreiche Integration in die Ausstellung zu gewährleisten.\nFachlicher Kontext graph TD\rA[Algae Care] --\u003e|Interagiert mit| B[Schülerinnen und Schüler]\rA --\u003e|Erkennt Eingaben| C[RFID-Reader]\rC --\u003e|Liest RFID-Tags aus| D[3D-Druckmodelle]\rD --\u003e|Repräsentieren Umweltfaktoren| E[Alltagsobjekte]\rA --\u003e|Visualisiert Feedback| F[Monitor]\rF --\u003e|Zeigt Auswirkungen in Echtzeit| G[Simuliertes Ökosystem]\rG --\u003e|Fördert Bewusstsein| B Benutzer (Schülerinnen und Schüler) Algae Care richtet sich primär an Jugendliche der 7. bis 9. Schulklasse, die das Exponat interaktiv erleben. Die Benutzer interagieren mit dem System durch haptische Eingaben wie das Platzieren von Alltagsobjekten (z. B. Plastikflaschen oder Kompost) und beobachten die Auswirkungen dieser Handlungen auf ein simuliertes Ökosystem. Diese Interaktion dient nicht nur der Wissensvermittlung, sondern soll auch das Bewusstsein für Nachhaltigkeit und Umweltschutz fördern.\n3D-Druckmodelle (Fremdsystem) Für die haptische Interaktion werden physische Alltagsobjekte wie Plastikflaschen oder Abfallstücke verwendet, die mithilfe von 3D-Druck erstellt werden. Diese Objekte repräsentieren verschiedene Umweltfaktoren und ermöglichen den Nutzern, durch einfache Handlungen komplexe ökologische Zusammenhänge zu verstehen. Der 3D-Druck und die Verarbeitung der Modelle erfolgen außerhalb des Systems, ihre Integration ist jedoch entscheidend für das Benutzererlebnis.\nVisualisierungssystem (Fremdsystem) Das Feedback zu den Benutzeraktionen wird über einen angeschlossenen Monitor dargestellt. Dieses Visualisierungssystem zeigt in Echtzeit, wie die Algen auf die Eingaben der Benutzer reagieren, und veranschaulicht, ob diese Eingaben einen positiven oder negativen Einfluss auf das Ökosystem haben. Der Monitor verzichtet bewusst auf Touchscreen-Funktionen, da diese für die angestrebte Interaktion nicht erforderlich sind. Stattdessen liegt der Fokus auf der klaren und anschaulichen Darstellung der Auswirkungen.\nRFID-Reader (Fremdsystem) Der RFID-Reader wird eingesetzt, um die 3D-gedruckten Alltagsobjekte zuverlässig zu erkennen und die Benutzerinteraktionen mit dem Exponat zu ermöglichen. Jedes Objekt ist mit einem RFID-Tag ausgestattet, das vom Reader ausgelesen wird, sobald das Objekt in das dafür vorgesehene Eingabefeld platziert wird.\nDer RFID-Reader dient dabei als zentrale Schnittstelle zur Erkennung und Zuordnung der Objekte. Auf Basis der erkannten Objekte bewertet das System deren Auswirkungen auf das simulierte Ökosystem und stellt die Ergebnisse visuell auf dem Monitor dar.\nDie Nutzung eines RFID-Readers bietet folgende Vorteile:\nRobuste Erkennung: Jedes Objekt wird eindeutig identifiziert, wodurch Fehleingaben minimiert werden. Kontaktlose Bedienung: Die Interaktion ist einfach und intuitiv, ohne dass mechanische Teile oder Sensoren verschleißen. Flexibilität: Neue Objekte können durch Hinzufügen passender RFID-Tags leicht in das System integriert werden. Durch den Einsatz des RFID-Readers wird sichergestellt, dass die Eingaben der Benutzer präzise erkannt und korrekt verarbeitet werden, was das Nutzererlebnis verbessert und die Interaktion mit dem Exponat erleichtert.\nTechnischer- oder Verteilungskontext Übersicht Der technische Kontext von Algae Care beschreibt die Interaktion des Systems mit seinen Hauptkomponenten und deren Umgebung. Das System basiert auf einer modularen Architektur, die die Verarbeitung von Eingaben, die Simulation von Umweltreaktionen und die Visualisierung der Ergebnisse umfasst. Es wurde entwickelt, um sowohl robust als auch flexibel zu sein und kann unabhängig von externen Systemen betrieben werden.\nHauptkomponenten und deren Rollen Raspberry Pi (zentrale Recheneinheit): Verantwortlich für die Verarbeitung der RFID-Eingaben, die Durchführung der Simulationen und die Steuerung der visuellen Ausgaben. Betriebssystem: Raspberry Pi OS. Java 21 wird als Hauptprogrammiersprache verwendet, unterstützt durch die Pi4J-Bibliothek zur Hardwarekommunikation. RFID-Reader: Eingabegerät zur Identifikation der 3D-gedruckten Alltagsobjekte, basierend auf RFID-Tags. Verbindung über USB oder GPIO-Pins. Daten werden direkt an die zentrale Anwendung weitergeleitet. Monitor (Visualisierung): Dient als Anzeige für die Simulationsergebnisse und Benutzeraktionen. Verbindung über HDMI, gesteuert durch die Java-Anwendung. 3D-Druckobjekte mit RFID-Tags: Physische Objekte, die vom Benutzer als Eingabe verwendet werden. Tags enthalten eindeutige Identifikationsdaten, die vom RFID-Reader gelesen werden. Datenfluss und Interaktion Eingabe: Benutzer platzieren ein 3D-Objekt in den vorgesehenen Bereich. Der RFID-Reader erfasst die Tag-Daten und übermittelt sie an die Anwendung. Verarbeitung: Die Anwendung interpretiert die Daten und simuliert die Auswirkungen der Eingabe auf das Ökosystem. **Ausgabe: **Die Ergebnisse der Simulation werden in Echtzeit auf dem Monitor visualisiert, einschließlich positiver oder negativer Auswirkungen auf die Algenpopulation. Externe Abhängigkeiten Hardware-Kompatibilität: Sicherstellung der Funktionalität mit Raspberry Pi 5 und Pi4J-Bibliothek. Bei Bedarf kann ein Mikrocontroller (z. B. Arduino) als Vermittler eingesetzt werden. Offline-Fähigkeit: Das System benötigt keine Internetverbindung und ist vollständig autark. Technische Herausforderungen und Lösungen Störungsfreiheit: Durch die Verwendung von LF-RFID-Tags wird sichergestellt, dass benachbarte Tags nicht versehentlich ausgelesen werden. Flexibilität: Konfigurierbare Parameter (z. B. Sprache und Simulationseinstellungen) ermöglichen einfache Anpassungen über eine zentrale Konfigurationsdatei. Fazit Der technische Kontext von Algae Care kombiniert robuste Hardware mit effizienter Software, um eine interaktive und benutzerfreundliche Erfahrung zu schaffen. Die Architektur gewährleistet, dass das System unabhängig von externen Ressourcen arbeitet, flexibel erweitert werden kann und gleichzeitig den spezifischen Anforderungen einer Ausstellung gerecht wird."},"title":"Kontextabgrenzung"},"/sad/laufzeitsicht/":{"data":{"":"","beschreibung-der-abläufe#Beschreibung der Abläufe":"","fazit#Fazit":"(der wichtigsten Abläufe)\nTODO\nSequenzdiagramm TODO\nBeschreibung der Abläufe TODO\nFazit TODO","sequenzdiagramm#Sequenzdiagramm":""},"title":"Laufzeitsicht"},"/sad/qualit%C3%A4tsziele/":{"data":{"":"Die zentralen Qualitätsziele von Algae Care wurden auf Basis der Anforderungen an das Projekt formuliert, um die Funktionalität, Wartbarkeit und den Betrieb des Exponats optimal zu gewährleisten. Die folgende Tabelle gibt eine Übersicht, wobei die Reihenfolge eine grobe Orientierung hinsichtlich der Priorität bietet:\nQualitätsziel Motivation und Erläuterung Benutzerfreundlichkeit Das Exponat richtet sich an Jugendliche der 7. bis 9. Schulklasse. Es muss selbsterklärend sein oder in 30 Sekunden erklärt werden können. Schnelle Antwortzeit Um das Interesse der Jugendlichen aufrechtzuerhalten, darf es keine Verzögerungen in der Interaktion geben. Flexibilität (Konfigurierbarkeit) Konfigurierbare Parameter und eine einfache Sprachumschaltung (D, F, E) erlauben eine Anpassung an verschiedene Ausstellungskontexte. Transportierbarkeit Das Exponat muss leicht und sicher von ein bis zwei Personen transportiert, schnell auf- und abgebaut werden können. Autarke Nutzung Das System soll ohne Internetverbindung funktionieren, um auch in Offline-Umgebungen eingesetzt werden zu können. Wartbarkeit Standardisierte Anschlüsse und ein zugängliches Innenleben ermöglichen einfache Wartung und Anpassungen. Interaktivität und Haptik Durch die Integration haptischer Elemente (z. B. Spielfiguren, Bedienelemente) wird die Interaktion und das Nutzererlebnis verbessert. Nachhaltigkeit Der Fokus auf die Rolle und den Erhalt von Algen vermittelt eine wichtige Botschaft zum Umweltschutz. Diese Qualitätsziele sollen sicherstellen, dass Algae Care nicht nur ein faszinierendes Exponat ist, sondern auch den funktionalen und technischen Anforderungen der Ausstellung gerecht wird. Die Qualitätsszenarien in den nachfolgenden Abschnitten konkretisieren diese Ziele und dienen als Grundlage für die Bewertung ihrer Umsetzung."},"title":"Qualitätsziele"},"/sad/randbedingungen/":{"data":{"":"","konventionen#Konventionen":"Beim Lösungsentwurf mussten verschiedene Randbedingungen berücksichtigt werden, die auch weiterhin in der Lösung wirksam sind. Dieser Abschnitt beschreibt diese Randbedingungen und erläutert, wo notwendig, deren Motivation und Auswirkungen.\nTechnische Randbedingungen Randbedingung Erläuterungen, Hintergrund Moderate Hardwareausstattung Das Exponat soll auf marktüblicher Standard-Hardware wie Raspberry Pi oder einem Notebook betrieben werden können, um einen einfachen Einsatz in verschiedenen Ausstellungsorten zu gewährleisten. Betrieb ohne Internet Das System muss offline funktionieren, da die Ausstellung an Orten ohne stabile Internetverbindung stattfinden kann. Eine Nutzung mit lokalem Netzwerk (WIFI) ist optional möglich. Mehrsprachigkeit Das Exponat soll mehrsprachig (D, F, E) einsetzbar sein. Texte und Strings müssen ausgelagert werden, um eine schnelle Anpassung zu ermöglichen. Übersetzungen werden von Primeo Energie bereitgestellt. Implementierung in Java 21 Die Anwendung wird in Java 21 entwickelt und nutzt die Library Pi4J, um sowohl moderne Standards zu erfüllen als auch eine einfache Integration mit Hardware-Komponenten zu ermöglichen. Konfigurierbare Parameter Parameter wie Sprache oder bestimmte Spiel- und Simulationsfunktionen sollen in einer leicht anpassbaren Konfigurationsdatei (app.properties) ausgelagert werden. Fremdsoftware frei verfügbar Falls Fremdsoftware oder externe Bibliotheken verwendet werden, müssen diese kostenlos und frei verfügbar sein, um die Kosten für den Betrieb niedrig zu halten. Transportierbarkeit Das Exponat muss leicht und sicher transportierbar sein, idealerweise von einer oder maximal zwei Personen. Es sollte schnell auf- und abbaubar sein, um eine einfache Handhabung bei wechselnden Ausstellungsorten zu gewährleisten. Standardisierte Anschlüsse Hardware-Anschlüsse müssen gut zugänglich und standardisiert sein (z. B. USB, HDMI), um einfache Wartung und Integration sicherzustellen. Organisatorische Randbedingungen // TODO: Organisatorische Randbedingungen ergänzen\nKonventionen Konvention Erläuterungen, Hintergrund Architekturdokumentation Terminologie und Gliederung basieren auf dem deutschen arc42-Template in der Version 6.0. Dies gewährleistet eine einheitliche und nachvollziehbare Struktur. Kodierrichtlinien für Java Es werden die Java Coding Conventions von Sun/Oracle eingehalten, geprüft mit Tools wie CheckStyle, um einen konsistenten und wartbaren Quellcode zu gewährleisten. Sprache (Deutsch vs. Englisch) Bezeichnungen in Diagrammen und Texten der Architekturdokumentation werden in Deutsch verfasst, um die Zielgruppe (Schülerinnen und Schüler) besser anzusprechen. Im Java-Quelltext werden deutsche Bezeichner verwendet, sofern die Java Coding Conventions dies nicht einschränken. Mehrsprachigkeit Texte und Strings sind in die Konfiguration ausgelagert, um eine einfache Anpassung an Deutsch, Französisch und Englisch zu ermöglichen. Hardware-Schnittstellenstandards Standards wie USB und HDMI werden eingehalten, um die Kompatibilität und Wartbarkeit des Systems zu fördern. Simulation und Datenformate Es werden etablierte Standards für Datenspeicherung und Austausch verwendet (z. B. JSON oder XML). Proprietäre Formate werden vermieden, um Interoperabilität sicherzustellen. Haptische und visuelle Elemente Die Gestaltung haptischer Komponenten orientiert sich an intuitiven Designstandards, um die Nutzung durch die Zielgruppe zu erleichtern. Dokumentation von Änderungen Änderungen am Quellcode und an der Architektur werden klar dokumentiert, um eine lückenlose Nachvollziehbarkeit für die Wartung zu gewährleisten. Diese Konventionen legen die Grundlage für ein einheitliches und leicht verständliches System, das den Anforderungen an Funktionalität, Benutzerfreundlichkeit und Wartbarkeit gerecht wird.","organisatorische-randbedingungen#Organisatorische Randbedingungen":"","technische-randbedingungen#Technische Randbedingungen":""},"title":"Randbedingungen"},"/sad/verteilungssicht/":{"data":{"":"","betriebsmodus#Betriebsmodus":"","hardwarekomponenten#Hardwarekomponenten":"","softwarekomponenten#Softwarekomponenten":"","verteilung-der-funktionalitäten#Verteilung der Funktionalitäten":"(welche Software-Teile laufen auf welchen Maschinen)\nDiese Sicht beschreibt den Betrieb der Algae Care-Applikation und deren Verteilung auf verschiedene Hardware-Komponenten. Das System wurde so konzipiert, dass es effizient und robust in einem Ausstellungskontext funktioniert. Die Architektur nutzt einen modularen Ansatz, um die einzelnen Komponenten klar voneinander zu trennen und die Integration sowie Wartbarkeit zu erleichtern.\nHardwarekomponenten Raspberry Pi (Zentrale Recheneinheit): Die Hauptanwendung läuft auf einem Raspberry Pi, der die gesamte Logik der Anwendung verwaltet. Er steuert die Erkennung der Eingaben, die Berechnung der Simulation und die Ausgabe der Visualisierungen. Der Raspberry Pi bietet eine energieeffiziente und kompakte Plattform, die leicht transportierbar und für Ausstellungen ideal geeignet ist. Monitor (Visualisierung): Ein angeschlossener Monitor dient zur Darstellung der Simulationsergebnisse und gibt visuelles Feedback zu den Aktionen der Benutzer. Die Verbindung erfolgt über HDMI, und die Anzeige wird in Echtzeit durch die Hauptanwendung gesteuert. RFID-Reader (Eingabeerkennung): Der RFID-Reader ist über USB mit dem Raspberry Pi verbunden. Er liest die Tags der 3D-gedruckten Alltagsobjekte aus und überträgt diese Informationen an die Anwendung. Die Erkennung erfolgt zuverlässig und kontaktlos, was die Benutzerfreundlichkeit und Robustheit des Systems erhöht. 3D-Druckmodelle (Eingabeobjekte): Die Objekte dienen als physische Eingabe und tragen RFID-Tags, die vom Reader identifiziert werden. Diese repräsentieren unterschiedliche Umweltfaktoren, die im System simuliert werden. Softwarekomponenten Anwendung (Java-basiert): Die Anwendung ist in Java 21 implementiert und läuft vollständig auf dem Raspberry Pi. Sie beinhaltet: Die Verarbeitung der RFID-Daten. Die Simulationslogik zur Bewertung der Eingaben. Die Generierung von Visualisierungen für den Monitor. Konfigurationsdatei: Die Anwendung nutzt eine zentrale Konfigurationsdatei (app.properties), um Parameter wie Spracheinstellungen oder Simulationswerte flexibel anzupassen. Änderungen können direkt vorgenommen werden, ohne den Code zu modifizieren. Betriebsmodus Offline-Betrieb: Algae Care ist vollständig offline-fähig. Alle notwendigen Daten und Programme befinden sich lokal auf dem Raspberry Pi, was den Einsatz auch an Orten ohne Internetverbindung ermöglicht. Autostart: Beim Anschließen der Stromversorgung startet das System automatisch. Dies erleichtert den Betrieb in Ausstellungskontexten, wo eine schnelle und einfache Inbetriebnahme erforderlich ist. Verteilung der Funktionalitäten Eingabe: Die Eingabe erfolgt durch das Platzieren der 3D-gedruckten Objekte in den vorgesehenen Bereich, wo der RFID-Reader die Tags ausliest. Verarbeitung: Der Raspberry Pi verarbeitet die Eingaben und berechnet deren Auswirkungen auf das simulierte Ökosystem. Ausgabe: Die Ergebnisse werden visuell auf dem Monitor dargestellt, sodass Benutzer die Auswirkungen ihrer Aktionen in Echtzeit nachvollziehen können. Die Verteilungssicht von Algae Care zeigt, wie die einzelnen Komponenten des Systems zusammenarbeiten, um eine intuitive Benutzererfahrung und einen reibungslosen Betrieb im Ausstellungskontext zu gewährleisten."},"title":"Verteilungssicht"},"/testing/1.0-smoke-tests/case-1.1/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob die Anwendung ohne Fehler gestartet werden kann.\nAnnahmen und Voraussetzungen Die Anwendung ist auf dem Testgerät installiert oder bereitgestellt.\nTestdaten …\nAuszuführende Schritte Starte die Anwendung. Beobachte den Übergang zum “Hauptmenü”. Erwartetes Ergebnis Die Anwendung startet fehlerfrei und zeigt das “Hauptmenü” an.","testdaten#Testdaten":""},"title":"TC 1.1 Anwendung starten"},"/testing/1.0-smoke-tests/case-1.2/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob die Anwendung korrekt beendet werden kann.\nAnnahmen und Voraussetzungen Die Anwendung läuft.\nTestdaten …\nAuszuführende Schritte Wähle die Option “Beenden” im Hauptmenü. Beobachte, ob die Anwendung geschlossen wird. Erwartetes Ergebnis Die Anwendung wird fehlerfrei beendet.","testdaten#Testdaten":""},"title":"TC 1.2 Anwendung beenden"},"/testing/2.0-funktionstests/case-2.1/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Testen, was passiert, wenn der Nutzer nichts macht.\nAnnahmen und Voraussetzungen Die Anwendung läuft.\nTestdaten Zeitintervall ohne Eingabe (z. B. 15 Sekunden).\nAuszuführende Schritte Lasse die Anwendung laufen, ohne etwas einzuwerfen. Beobachte, ob die Anwendung fehlerfrei weiterläuft. Erwartetes Ergebnis Animation wird auf loop abgespielt und Nutzer wird aufgefordert den Axolotl einzuwerfen.","testdaten#Testdaten":""},"title":"TC 2.1 Anwendung läuft und Nutzer tut nichts"},"/testing/2.0-funktionstests/case-2.2/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob die Eingabe des Axolotls akzeptiert wird.\nAnnahmen und Voraussetzungen Der Nutzer hat Zugriff auf das Axolotl-Objekt.\nTestdaten Axolotl-Objekt.\nAuszuführende Schritte Nimm das Axolotl-Objekt aus und werfe es ein. Beobachte, ob das System korrekt darauf reagiert. Erwartetes Ergebnis Das Axolotl wird angezeigt und erklärt das Exponat.","testdaten#Testdaten":""},"title":"TC 2.2 Einwurf des Axolotls"},"/testing/2.0-funktionstests/case-2.3/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob das System korrekt auf das Einwerfen eines Objekts reagiert.\nAnnahmen und Voraussetzungen Der Nutzer hat Zugriff auf verschiedene Objekte.\nTestdaten Eingabeobjekt: Plastik, Nährstoffe, Schadstoffe.\nAuszuführende Schritte Wähle ein Objekt aus (z. B. Auto) und werfe es ein. Beobachte, ob das System das Objekt erkennt. Erwartetes Ergebnis Das System liest die Daten des Objekts und zeigt eine entsprechende Reaktion an.","testdaten#Testdaten":""},"title":"TC 2.3 Einwurf von Objekten"},"/testing/2.0-funktionstests/case-2.4/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob das System korrekt mit unbekannten Objekten umgeht.\nAnnahmen und Voraussetzungen Der Nutzer kann ein beliebiges Objekt einwerfen.\nTestdaten Eingabe: Ein nicht definiertes Objekt.\nAuszuführende Schritte Wähle ein nicht definiertes Objekt aus und werfe es ein. Warte auf eine Reaktion Beobachte, wie das System reagiert. Erwartetes Ergebnis Das System gibt eine Fehlermeldung oder eine entsprechende Meldung aus.","testdaten#Testdaten":""},"title":"TC 2.4 Objekt nicht erkannt"},"/testing/2.0-funktionstests/case-2.5/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob die Werte (Sauerstoff, pH-Wert, Temperatur) korrekt analysiert werden.\nAnnahmen und Voraussetzungen Das System läuft und ein Objekt wurde erkannt.\nTestdaten Eingabewerte: Sauerstoff (-10%), pH-Wert (+1), Temperatur (+5°C).\nAuszuführende Schritte Wirf ein definiertes Objekt ein. Überprüfe, ob die Werte korrekt angepasst werden. Erwartetes Ergebnis Das System passt die Werte an und zeigt die Änderungen an.","testdaten#Testdaten":""},"title":"TC 2.5 Daten des Objekts überprüfen"},"/testing/2.0-funktionstests/case-2.6/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob das Ökosystem korrekt auf die neuen Werte reagiert.\nAnnahmen und Voraussetzungen Die Werte des Objekts wurden überprüft.\nTestdaten Angepasste Werte: Sauerstoff \u003c 30%, pH-Wert \u003e 9, Temperatur \u003e 35°C.\nAuszuführende Schritte Beobachte, wie sich das Ökosystem auf dem Bildschirm anpasst. Beobachte, wie sich die Analogen-Anzeigen anpassen. Teste verschiedene Werte. Erwartetes Ergebnis Das Ökosystem reagiert sichtbar","testdaten#Testdaten":""},"title":"TC 2.6 Ökosystem anpassen"},"/testing/2.0-funktionstests/case-2.7/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen, ob das Axolotl die Veränderungen kommentiert.\nAnnahmen und Voraussetzungen Eingaben wurden gemacht, und Werte haben sich geändert.\nTestdaten Änderungen: Sauerstoff (-10%), pH-Wert (+1).\nAuszuführende Schritte Beobachte die Kommentare des Axolotls nach einer Eingabe. Erwartetes Ergebnis Das Axolotl gibt verständliche und logische Kommentare zu den Änderungen.","testdaten#Testdaten":""},"title":"TC 2.7 Kommentierung durch das Axolotl"},"/testing/2.0-funktionstests/case-2.8/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Testen, wie das System reagiert, wenn das Ökosystem unbewohnbar wird.\nAnnahmen und Voraussetzungen Das Ökosystem wurde durch Eingaben stark gestört.\nTestdaten Eingaben: Mehrfach das Flugzeug oder Auto einwerfen.\nAuszuführende Schritte Führe mehrmals das Flugzeug ein bis der Schlechte Endergebnis erreicht wird. Beobachte, ob das Axolotl flüchtet und die Simulation endet. Erwartetes Ergebnis Das System zeigt eine Warnung, das Axolotl flüchtet, und der Zustand des Ökosystems wird angezeigt.","testdaten#Testdaten":""},"title":"TC 2.8 Ökosystem nicht mehr bewohnbar"},"/testing/2.0-funktionstests/case-2.9/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Testen, ob die Eingabe nach der Kommentierung freigegeben wird.\nAnnahmen und Voraussetzungen Eine Eingabe wurde verarbeitet.\nTestdaten Eingabe: Ein Objekt\nAuszuführende Schritte Beobachte, kann, nach der Eingabe, die Klappe Aktiviert werden. Beobachte, ob der Nutzer nach der Kommentierung neue Eingaben machen kann. Erwartetes Ergebnis Das System gibt den fall frei, nach ablauf kann der Prozess wiederholt werden.","testdaten#Testdaten":""},"title":"TC 2.9 Input Freigabe"},"/testing/3.0-iintegrationstests/case-3.1/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung, ob der Einwurf eines Objekts korrekt verarbeitet wird und die Anzeigen (Sauerstoff, CO₂, Temperatur) entsprechend aktualisiert werden.\nAnnahmen und Voraussetzungen Das System erkennt Objekte korrekt (Funktionstests bestanden). Anzeigen für Sauerstoff, CO₂ und Temperatur funktionieren einzeln wie vorgesehen. Testdaten Eingabewert: Ein Objekt (z. B. Plastikflasche).\nErwartete Änderung: CO₂ erhöht sich, Sauerstoff sinkt, Temperatur steigt.\nAuszuführende Schritte Starte die Anwendung und navigiere zur Simulationsansicht (Screen, der den Einwurf fordert). Wirf das Objekt (Plastikflasche) in den Einwurfbereich. Beobachte, ob das System die Anzeige für CO₂, Sauerstoff und Temperatur aktualisiert. Erwartetes Ergebnis Das System erkennt das Objekt und aktualisiert die Anzeigen entsprechend:\nCO₂: +\nSauerstoff: -\nTemperatur: +\nKeine Fehler oder Verzögerungen treten auf.","testdaten#Testdaten":""},"title":"TC 3.1 Einwurf eines Objekts → Reaktion des Systems"},"/testing/3.0-iintegrationstests/case-3.2/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung, ob das Ziehen des Hebels eine Interaktion mit dem Axolotl auslöst (z. B. Animation oder Kommentar).\nAnnahmen und Voraussetzungen Der Hebel ist funktional. Das Axolotl reagiert auf Eingaben mit Animationen oder Kommentaren. Testdaten Aktion: Hebel wird gezogen.\nErwartete Reaktion: Das Axolotl gibt eine Text- oder Sprachmeldung aus.\nAuszuführende Schritte Starte die Anwendung und navigiere zur Simulationsansicht (Screen, der auffordert den Hebel zu ziehen). Ziehe den Hebel. Beobachte die Reaktion des Axolotls (z. B. Animation, Kommentar). Erwartetes Ergebnis Das Axolotl reagiert sichtbar (Animation oder Text).\nDie Aktion wird ohne Verzögerung oder Fehler ausgeführt.","testdaten#Testdaten":""},"title":"TC 3.2 Hebel ziehen → Reaktion des Axolotls"},"/testing/3.0-iintegrationstests/case-3.3/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung, ob die Anzeigen (Sauerstoff, CO₂, Temperatur) korrekt aktualisiert werden, wenn mehrere Objekte nacheinander eingeworfen werden.\nAnnahmen und Voraussetzungen Die Anzeigen aktualisieren sich korrekt für einzelne Eingaben. Testdaten Eingaben:\nPlastikflasche → CO₂: + , Sauerstoff: - , Temperatur: + Velo → CO₂: - , Sauerstoff: + , Temperatur: - Auszuführende Schritte Starte die Anwendung und navigiere zur Simulationsansicht. Wirf nacheinander die Objekte (Plastikflasche, Velo) ein. Beobachte die Änderungen der Anzeigen. Erwartetes Ergebnis Nach Plastik:\nCO₂: + Sauerstoff: - Temperatur: + Nach sauberem Wasser:\nCO₂: - Sauerstoff: + Temperatur: - ","testdaten#Testdaten":""},"title":"TC 3.3 Anzeigenwechsel nach mehreren Eingaben"},"/testing/4.0-usability-tests/case-4.1/":{"data":{"":"","auswertung#Auswertung":"","einführung#Einführung":"","ergebnisse#Ergebnisse":"","fragestellungen#Fragestellungen":"","gesamtfazit#Gesamtfazit":" Datum Verantwortlich 27.11.2024 TM, UX Einführung Usability Testing ist ein zentraler Bestandteil des Entwicklungsprozesses, um sicherzustellen, dass ein Produkt benutzerfreundlich, verständlich und funktional ist. Ziel ist es, die Interaktion von Nutzern mit dem Prototyp zu analysieren, Schwachstellen zu identifizieren und Verbesserungspotenziale aufzudecken.\nFragestellungen Wie kommt die Idee bei den Nutzern an? Wie verständlich ist der erste Prototyp? Ist der Ablauf der Nutzung intuitiv? Werden die Funktionen und Anzeigen korrekt verstanden? Testobjekt Prototyp 1:\nEin low-fidelity Prototyp von einem Exponat, das die Nutzer spielerisch an das Thema Algen und Umweltbewusstsein heranführt. Mehr Details zum Prototyp auf Confluence.\nPlanung Umfang: Ein Usability-Test mit 3 Probanden, Fokus auf grundlegende Interaktion mit dem Prototyp.\nZeitplan: 5 Minuten pro Test, inklusive Einführung, Durchführung und Beobachtung.\nPotenzielles Risiko: Probanden könnten den Prototyp missverstehen.\nGegenmaßnahme: Kurze Einführung in die grundlegenden Funktionen.\nTestmethode Gewählte Methode: Beobachtung mit Think-Aloud-Methode.\nGrund: Direkte Einblicke in das Nutzerverhalten und die Denkprozesse, ohne die Interaktion zu beeinflussen.\nTest-Szenario Ort: FHNW, Schulzimmer\nUmgebung: Kontrollierte Testumgebung\nAblauf Einführung in das Szenario: „Erkunde den Prototyp und interagiere mit den Funktionen.“ Bei jeder Interaktion wird manuell Screen (Skizzen auf Papier) passend gewechselt. Beobachtung der Nutzung und Erfassung von Feedback. Testaufgaben Finde das Axolotl und wirf es in den vorgesehenen Bereich. Nutze den Hebel und beschreibe seine Funktion. Interagiere mit den Objekten. Beobachte die Änderungen im System nach der Interaktion. Beschreibe die Anzeigen für Sauerstoff, CO₂ und Temperatur. Probanden Anzahl: 3 Test-User\nProfil: Mitstudierende, die nicht in das Projekt involviert sind\nAlter: ca. 20 Jahre alt\nVorkenntnisse: Keine spezifischen Kenntnisse im Bereich des Prototyps\nInterview Kein strukturiertes Interview durchgeführt. Feedback und Beobachtungen wurden während und nach den Tests notiert.\nAuswertung Erfolge 3D-Objekte:\nBegeisterung über die visuelle Darstellung.\nBlinken und visuelle Hinweise:\nHilft den Nutzern, ihre Aufmerksamkeit auf wichtige Elemente zu lenken.\nAnzeigen für Sauerstoff, CO₂ und Temperatur:\nVerständlich und visuell ansprechend. Die Farbcodierung (rot = schlecht, grün = gut) wurde gelobt.\nProbleme Schwierigkeiten beim Finden des Axolotls:\nDas Axolotl wurde nicht sofort gefunden.\nEmpfehlung: Axolotl deutlicher sichtbar machen (z. B. Blinken oder besser positionieren).\nObjekte nicht direkt erkannt:\nNutzer konnten einige Objekte und deren Funktion nicht eindeutig identifizieren.\nEmpfehlung: Objekte deutlicher gestalten und beschriften.\nHebel-Notwendigkeit unklar:\nNutzer fragten nach der Notwendigkeit des Hebels.\nSchlussfolgerung: Hebel dient der Ansehnlichkeit des Exponats und als Bestätigungs-Funktion.\nErster Schritt nicht intuitiv:\nNutzer wünschten sich eine klarere Anleitung für den Start.\nSchlussfolgerung: Trichter und Hebel werden blinken, um den Start zu signalisieren. Konnte beim Prototyp 1 noch nicht dargestellt werden.\nWünsche der Nutzer Soundeffekte:\nSound, der bestimmte Aktionen begleitet, würde die Erfahrung verbessern.\nPositive Objekte:\nNutzer wünschten sich positivere Objekte, die klar mit einem positiven Effekt verknüpft sind.\nGlückliches Axolotl:\nBegeisterung über das Design des Axolotls, Wunsch nach mehr Interaktionen mit dessen Reaktionen.\nErgebnisse Bewertung der Probleme Schwerwiegende Probleme:\nAxolotl wurde schwer gefunden Hebel-Funktion war unklar Mittelschwere Probleme:\nObjekte wurden nicht direkt erkannt Erster Schritt war nicht intuitiv Geringfügige Probleme:\nSoundeffekte fehlen Gesamtfazit Der Prototyp wurde insgesamt positiv bewertet. Das Konzept und die visuelle Gestaltung kamen bei den Testpersonen gut an. Einige Usability-Probleme wurden identifiziert und priorisiert, um in der nächsten Iteration verbessert zu werden.","interview#Interview":"","planung#Planung":"","probanden#Probanden":"","test-szenario#Test-Szenario":"","testaufgaben#Testaufgaben":"","testmethode#Testmethode":"","testobjekt#Testobjekt":""},"title":"TC 4.1"},"/testing/4.0-usability-tests/case-4.2/":{"data":{"":"","auswertung-skalierung-1-5-sterne#Auswertung (Skalierung 1-5 Sterne)":"","einführung#Einführung":"","ergebnisse#Ergebnisse":"","fragestellungen#Fragestellungen":"","gesamtfazit#Gesamtfazit":" Datum Verantwortlich 02.04.2024 TM, UX, PM Einführung Der Usability-Test soll die Benutzerfreundlichkeit des Prototyps evaluieren und potenzielle Probleme bei der Interaktion mit dem System identifizieren. Dabei wird überprüft, ob die Nutzer das System intuitiv verstehen, die Funktionen korrekt nutzen können und die Interaktionen sinnvoll sind.\nFragestellungen Wie wird der Prototyp von den Nutzern wahrgenommen? Haben sie Spass am Spiel? Ist der erste Prototyp verständlich und benutzerfreundlich? Ist der Ablauf intuitiv? Werden die Funktionen und Anzeigen richtig verstanden? Testobjekt Prototyp 2:\nEin Prototyp, der Nutzern spielerisch das Thema Algen und Umweltbewusstsein näherbringt. Mehr Details zum Prototyp auf Confluence (Link tbd).\nPlanung Umfang: 5 bis 7 Probanden, Fokus auf grundlegende Interaktion mit dem Prototyp.\nZeitplan: 10 Minuten pro Test, inklusive Einführung, Durchführung und Feedback.\nPotenzielles Risiko: Probanden könnten den Prototyp missverstehen oder überfordert sein.\nGegenmaßnahme: Kurze Einführung in die grundlegenden Funktionen.\nTestmethode Gewählte Methode: Beobachtung mit Think-Aloud-Methode.\nGrund: Beobachtung der Nutzer und deren Denkprozesse während der Interaktion. Die Nutzer sollen laut aussprechen, was sie denken, um tiefere Einblicke in ihre Entscheidungen und Schwierigkeiten zu erhalten.\nTest-Szenario Ort: FHNW, Eingangshalle, Gebäude 1\nUmgebung: Kontrollierte Testumgebung\nAblauf Einführung: Kurze Vorstellung (Wer wir sind und was wir machen) Testaufgaben: siehe unten (Aufgaben werden nacheinander durchgeführt, um den Fokus zu behalten) Beobachtungen und Feedback: Während der Interaktion werden Beobachtungen gemacht und direktes Feedback eingeholt. Testaufgaben Werfe ein Objekt in den vorgesehenen Bereich. Nutze den Hebel und beschreibe seine Funktion. Interagiere mit den Objekten und beobachte die Änderungen im System. Beschreibe die Anzeigen für Sauerstoff, CO₂ und Temperatur. Probanden Anzahl: 5 bis 7 Testpersonen Profil: Schüler- und Schülerinnen Alter: 11 bis 15 Jahre alt\nVorkenntnisse: Keine spezifischen Kenntnisse im Bereich des Prototyps\nInterview Auswertung (Skalierung 1-5 Sterne) Hattet ihr Spass daran? Habt ihr etwas daraus gelernt? Habt ihr das Spiel verstanden? War es visuell ansprechbar? Erfolge Probleme Wünsche der Nutzer Ergebnisse Bewertung der Probleme Gesamtfazit ","interview#Interview":"","planung#Planung":"","probanden#Probanden":"","test-szenario#Test-Szenario":"","testaufgaben#Testaufgaben":"","testmethode#Testmethode":"","testobjekt#Testobjekt":""},"title":"TC 4.1"},"/testing/5.0-performance-tests/case-5.1/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen der Ladezeiten der Anwendung, um sicherzustellen, dass das Hauptmenü innerhalb eines akzeptablen Zeitrahmens (3 Sekunden) geladen wird.\nAnnahmen und Voraussetzungen Die Anwendung ist auf einem Testgerät installiert.\nTestdaten Gerät: Raspberry Pi 5\nVersion der Anwendung: Prototyp 2\nTimer-Tool: integriertes Performance-Mess-Tool\nAuszuführende Schritte Starte das Gerät und stelle sicher, dass keine anderen Anwendungen geöffnet sind. Öffne die Anwendung. Messe die Zeit von dem Moment, in dem die Anwendung gestartet wird, bis das Hauptmenü vollständig geladen ist (alle Elemente sichtbar und anklickbar). Wiederhole diesen Test zehnmal, um Durchschnittswerte zu ermitteln. Erwartetes Ergebnis Die Ladezeit bis zur vollständigen Anzeige des Hauptmenüs beträgt weniger als 3 Sekunden in mindestens 90 % der Tests. Es treten keine Fehler, Abstürze oder Verzögerungen auf, die den Ladevorgang beeinträchtigen.","testdaten#Testdaten":""},"title":"TC 5.1"},"/testing/5.0-performance-tests/case-5.2/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfen der Reaktionszeit des Systems, um sicherzustellen, dass Nutzereingaben (z. B. das Einwerfen eines Objekts) innerhalb von 500 Millisekunden verarbeitet und die entsprechende Aktion ausgelöst wird.\nAnnahmen und Voraussetzungen Die Anwendung ist auf einem Testgerät installiert. Der Prototyp verfügt über eine Funktion, die auf den Einwurf eines Objekts reagiert. Testdaten Eingabegerät: Trichter mit Hebel\nObjekt: Beispielobjekt (z.B. Plastikflasche)\nGerät: Raspberry Pi 5\nVersion der Anwendung: Prototyp 2\nTimer-Tool: Integrierte Debug-Konsole\nAuszuführende Schritte Starte die Anwendung und navigiere zur Simulationsansicht. Wähle ein Objekt (z. B. Plastikmüll) aus, wirf es in den Trichter und zieh den Hebel. Messe die Zeit vom Abschluss der Eingabe (Ziehen von Hebel) bis zur ersten sichtbaren Reaktion im System. Wiederhole diesen Test für mindestens drei verschiedene Objekte. Führe den Test dreimal pro Objekt durch, um Durchschnittswerte zu ermitteln. Erwartetes Ergebnis Die Reaktionszeit zwischen Nutzereingabe und sichtbarer Systemreaktion beträgt ≤ 500 Millisekunden in mindestens 80 % der Tests. Die Systemreaktion ist flüssig und frei von Ruckeln, Verzögerungen oder Fehlermeldungen.","testdaten#Testdaten":""},"title":"TC 5.2"},"/testing/6.0-hardware-tests/case-6.1/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung der Funktionalität des Bildschirmes.\nAnnahmen und Voraussetzungen Der Bildschirm ist, per HDMI, mit dem laufenden Raspberry pi verbunden und hat eine Stromversorgung\nTestdaten Gerät: Raspberry-Bildschirm\nAuszuführende Schritte Test Programm starten. Beobachten, ob das Test bild korrekt mit den Bildschirm-kannten parallel ist. Erwartetes Ergebnis Das Test bild füllt den gesamten Bildschirm und ist nicht verzehrt.","testdaten#Testdaten":""},"title":"TC 6.1 Bildschirm"},"/testing/6.0-hardware-tests/case-6.2/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung der Funktionalität der Lautsprecher.\nAnnahmen und Voraussetzungen Das Testprogramm ist aktiv und der vorgehende Schritt wurde durchlaufen.\nTestdaten Gerät:Lautsprecher\nAuszuführende Schritte Lautsprecher Test starten Bobachten, ob die Testtöne in diversen frequenzen abgespielt werden. Erwartetes Ergebnis Die Lautsprecher geben eine Folge von fünf tönen von tiefer zu hoher Frequenz.","testdaten#Testdaten":""},"title":"TC 6.2 Lautsprecher"},"/testing/6.0-hardware-tests/case-6.3/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung der Funktionalität des RFID-Scanners.\nAnnahmen und Voraussetzungen Das Testprogramm ist aktiv und der vorgehende Schritt wurde durchlaufen.\nTestdaten Geräte: Bildschirm, RFID-Scanner Testobjekt: 3 beliebige, zum Spiel gehörende, einlesbare Objekte.\nAuszuführende Schritte Objekt Einwerfen. Text ausgabe auf dem Bildschirm Lesen. Objekt entfernen. Die ersten drei Schritte zwei weitere male, mit ander Objekten, durchführen. Erwartetes Ergebnis Auf dem Bildschirm erscheint der zugehörige name, zum eingeworfenen Objekt.","testdaten#Testdaten":""},"title":"TC 6.3 RFID-Scanner"},"/testing/6.0-hardware-tests/case-6.4/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung der Funktionalität des Solenoid Bolzens.\nAnnahmen und Voraussetzungen Das Testprogramm ist aktiv und der vorgehende Schritt wurde durchlaufen.\nTestdaten Gerät: Solenoid-Bozen Testobjekt: ein beliebiges, zum Spiel gehörende, einlesbare Objekte.\nAuszuführende Schritte Das objekt einwerfen. Das Testprogramm laufen lassen Das objekt erneut einwerfen. Das objekt entfernen. Erwartetes Ergebnis Das objekt fällt nach dem Starten des Testprogramms durch die Klappe. Beim zweiten Einwurf ist die Klappe wieder geschlossen und das Objekt bleibt darauf stehen.","testdaten#Testdaten":""},"title":"TC 6.4 Solenoid-Bolt"},"/testing/6.0-hardware-tests/case-6.5/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung der Funktionalität der Stepper-Motoren\nAnnahmen und Voraussetzungen Das Testprogramm ist aktiv und der vorgehende Schritt wurde durchlaufen.\nTestdaten Gerät: Stepper-Motoren\nAuszuführende Schritte Testprogramm starten. Stepper Motoren beobachten. Erwartetes Ergebnis Die stepper motoren vollziehen eine vollständige umdrehung. Danach folgt eine vollständige Umdrehung in die entgegengesetzte Richtung.","testdaten#Testdaten":""},"title":"TC 6.5 Stepper-Motoren"},"/testing/6.0-hardware-tests/case-6.6/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung der Funktionalität der LEDs\nAnnahmen und Voraussetzungen Das Testprogramm ist aktiv und der vorgehende Schritt wurde durchlaufen.\nTestdaten Gerät: LEDs\nAuszuführende Schritte “Lampentest” Knopf im Testprogramm gedrückt halten. Erwartetes Ergebnis Solange der “Lampentest” Knopf gedrückt ist leuchten alle LEDs.","testdaten#Testdaten":""},"title":"TC 6.6 LEDs"},"/testing/6.0-hardware-tests/case-6.7/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":"Beschreibung Überprüfung der Funktionalität der Analog-Anzeigen.\nAnnahmen und Voraussetzungen Das Testprogramm ist aktiv und der vorgehende Schritt wurde durchlaufen.\nTestdaten Gerät: Analoganzeige(LED Streifen)\nAuszuführende Schritte Test program laufen lassen. Analoganzeige beobachten. Erwartetes Ergebnis Der LED Streifen leuchtet ine einer Abfolge von drei Zuständen:\nEin Viertel beleuchtet Die Hälfte beleuchtet Ganz beleuchtet ","testdaten#Testdaten":""},"title":"TC 6.7 Analog-Anzeigen"},"/testing/case-template/":{"data":{"":"","annahmen-und-voraussetzungen#Annahmen und Voraussetzungen":"","auszuführende-schritte#Auszuführende Schritte":"","beschreibung#Beschreibung":"","erwartetes-ergebnis#Erwartetes Ergebnis":" Datum Verantwortlich dd.mm.yyyy Max Muster Beschreibung Diese Beschreibung sollte detailliert beschreiben, welche Einheit, Funktion oder Funktion getestet oder verifiziert wird.\nAnnahmen und Voraussetzungen Dies beinhaltet alle Bedingungen, die vor der Ausführung des Testfalls erfüllt sein müssen. Ein Beispiel wäre das Erfordernis eines gültigen Outlook-Kontos für eine Anmeldung.\nTestdaten …\nAuszuführende Schritte Dies sollten leicht wiederholbare Schritte sein, wie sie aus Sicht des Endbenutzers ausgeführt werden. Ein Testfall für die Anmeldung bei einem E-Mail-Server kann beispielsweise die folgenden Schritte umfassen:\nÖffnen Sie die E-Mail-Server-Webseite.\rGeben Sie den Benutzernamen ein.\rPasswort eingeben.\rKlicken Sie auf \"Enter\" oder \"Login\".\rErwartetes Ergebnis Dies zeigt das Ergebnis an, das nach der Ausführung des Testfallschritts erwartet wird. Nach Eingabe der richtigen Anmeldeinformationen wäre das erwartete Ergebnis eine erfolgreiche Anmeldung.","testdaten#Testdaten":""},"title":"TC 0.0 Testname"},"/testing/testplan/":{"data":{"":"","endprodukt#Endprodukt":"## Einführung Testing\rSmoke Tests: Grundlegende Tests, um sicherzustellen, dass die Kernfunktionalität vorhanden ist. Funktionstests: Tests einzelner Module wie Eingabefunktionen und Simulation. Integrationstests: Sicherstellen, dass alle Module zusammenarbeiten. Usability-Tests: Tests mit der Zielgruppe durchführen. Performance-Tests: Vor dem Release, um sicherzustellen, dass alles wie geplant funktioniert. Hardware-Tests: Nach Einbau oder reparatur der Hardware. Regelmässige Tests Intervall Testart Test Verantwortlich Status Wöchentlich Smoke Tests TC 1.1, TC 1.2 TM Nach jedem Update Funktionstests TC 2.1 bis 2.9 TM Nach Modul-Integration Integrationstests TC 3.1 bis 3.3 TM Nach Fertigstellung von Prototyp Usability-Tests TC 4.0 TM, UX Nach Fertigstellung von Prototyp Performance-Tests TC 5.2, TC 5.2 TM Nach Fertigstellung von Produkt Hardware-Tests TC 6.1 bis 6.4 TM Prototyp 1 Ein low fidelity Prototyp von einem Exponat, das die Nutzer spielerisch an das Thema Algen und Umweltbewusstsein heranführt. Mehr Details zum Prototyp und zur Herstellung auf Confluence.\nZeitplan Datum Testart Test Verantwortlich Status 27.11.2024 Usability-Test TC 4.1 TM, UX durchgeführt Prototyp 2 Dieser Prototyp diente dazu, erste Usability-Tests mit unserer Zielgruppe durchzuführen um zu sehen, wie das Grundkonzept unseres Exponats wahrgenommen wird. Mehr Details zum Prototyp und zur Herstellung auf Confluence.\nZeitplan von Prototyp 2 Datum Testart Test Verantwortlich Status 02.04.2025 Usability-Test TC 4.2 TM , UX durchgeführt Endprodukt Beschreibung Prototyp und Bild. Link zu Confluence.\nZeitplan von Endprodukt Datum Testart Test Verantwortlich Status tbd Usability-Test TC 4.3 TM , UX ","prototyp-1#Prototyp 1":"","prototyp-2#Prototyp 2":"","regelmässige-tests#Regelmässige Tests":""},"title":"Testplan"},"/testing/usability-test-template/":{"data":{"":"","auswertung#Auswertung":"","einführung#Einführung":"","ergebnisse#Ergebnisse":"","fragestellungen#Fragestellungen":"","gesamtfazit#Gesamtfazit":" Datum Verantwortlich dd.mm.yyyy Martin Muster Einführung Einführung in das Thema Usability Testing\nFragestellungen Was ist die Fragestellung und das Testziel\nFragestellung 1 Fragestellung 1 Testobjekt Welchen Prototypen haben Sie getestet und welchen Bereich davon\nPrototyp xy:\nMehr Details zum Prototyp auf Confluence.\nPlanung Ihre Planung des Tests, Umfang, Zeitplan, Risikomanagement\nUmfang:\nZeitplan:\nPotenzielles Risiko:\nGegenmaßnahme:\nTestmethode Welche Testmethode haben Sie gewählt\nGewählte Methode:\nGrund:\nTest-Szenario Wie haben Sie und wo getestet\nOrt:\nUmgebung:\nAblauf Schritt 1 Schritt 2 Schritt 3 Testaufgaben Wie lauten die Testaufgaben\nAufgabe 1 Aufgabe 2 Aufgabe 3 Probanden Wer sind die Probanden mit welchen Sie die Tests durchführen\nAnzahl:\nProfil:\nAlter:\nVorkenntnisse:\nInterview Fand ein Interview oder eine Befragung vor oder nach dem Test statt?\nAuswertung Erfolge Erfolg 1:\nInfo zu Erfolg 1\nErfolg 3:\nInfo zu Erfolg 3\nErfolg 3:\nInfo zu Erfolg 3\nProbleme Problem 1:\nInfo zu Problem 1\nEmpfehlung:\nProblem 2:\nInfo zu Problem 2\nEmpfehlung:\nProblem 3:\nInfo zu Problem 3\nEmpfehlung:\nWünsche der Nutzer Wunsch 1:\nInfo zu Wunsch 1\nWunsch 2:\nInfo zu Wunsch 2\nWunsch 3:\nInfo zu Wunsch 3\nErgebnisse Bewertung der Probleme Schwerwiegende Probleme:\nProblem 1 Problem 2 Mittelschwere Probleme:\nProblem 3 Problem 4 Geringfügige Probleme:\nProblem 5 Gesamtfazit Gesamtfazit.","interview#Interview":"","planung#Planung":"","probanden#Probanden":"","test-szenario#Test-Szenario":"","testaufgaben#Testaufgaben":"","testmethode#Testmethode":"","testobjekt#Testobjekt":""},"title":"TC 4.0 Testname"}}